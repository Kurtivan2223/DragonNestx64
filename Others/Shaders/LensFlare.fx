//////////////////////////////////////////////////////////////////////////////////////////////
// World Mat Param
//////////////////////////////////////////////////////////////////////////////////////////////
float4x4 g_WorldViewProjMat			: WORLDVIEWPROJ;
float4x4 g_WorldMat					: WORLD;

float g_fElapsedTime = 0;

//////////////////////////////////////////////////////////////////////////////////////////////
// Shared Param
//////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////
// Global Param
//////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////
// Custom Param
//////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////
// Vertex Buffer Declaration
//////////////////////////////////////////////////////////////////////////////////////////////
struct VertexInput
{
    float3 Position				: POSITION;
    float2 TexCoord0			: TEXCOORD0;
};

struct VertexOutput
{
    float4 Position				: POSITION;
    float2 TexCoord0			: TEXCOORD0;
};

//////////////////////////////////////////////////////////////////////////////////////////////
// Start Vertex Shader
//////////////////////////////////////////////////////////////////////////////////////////////
VertexOutput LensFlareVS( VertexInput Input ) 
{
	VertexOutput Output;

	Output.Position = mul( float4( Input.Position.xyz, 1.0f ) , g_WorldViewProjMat );
	Output.TexCoord0 = Input.TexCoord0;

	//float3 WorldPos = mul( float4( Input.Position.xyz, 1.0f ) , g_WorldMat );
	//float3 WorldNormal = mul( Input.Normal, g_WorldMat );
	//Output.EyeVec = normalize( WorldPos - g_InvViewMat[ 3 ].xyz );
	//Output.Reflect = normalize( reflect( Output.EyeVec, WorldNormal ) );
	
	return Output;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Start Pixel Shader
//////////////////////////////////////////////////////////////////////////////////////////////
float4 LensFlarePS( VertexOutput Input ) : COLOR
{
	/*float fTime = g_fElapsedTime;
	float2 VecDirection = float2( -fTime * g_fWaterDirectionX, fTime * g_fWaterDirectionZ );
	float3 NormalTex = ( tex2D( g_NormalSampler, Input.TexCoord0 + VecDirection ).xyz - 0.5f ) * g_fWaterWaveStrength;
	float2 TexCoord;
	TexCoord.x = frac( atan2( Input.Reflect.x, Input.Reflect.z ) / ( 6.283185308 ) + 1.0f );
	TexCoord.y = ( 1.0f - Input.Reflect.y ) * 0.325f;
	TexCoord += NormalTex.xy;
	float4 Result = tex2D( g_EnvSampler, TexCoord );
    Result.a = 1.4f - clamp( dot( float3( 0.0f, -1.0f, 0.0f ), Input.EyeVec ), 0.0f, 1.0f );
    return Result;
    */
    
    return float4(1,1,1,1);
	
}


//////////////////////////////////////////////////////////////////////////////////////////////
// Start Technique
//////////////////////////////////////////////////////////////////////////////////////////////
technique LensflareTech
{
    pass p0 
    {		
		VertexShader = compile vs_2_0 LensFlareVS();
		PixelShader  = compile ps_2_0 LensFlarePS();
    }
}
